#version 430
// full Menger-sponge ray-march port of Inigo Quilezâ€™s Shadertoy code
// https://iquilezles.org/articles/menger

layout (local_size_x = 16, local_size_y = 16) in;

layout (rgba32f, binding = 0) uniform image2D imgOutput;

uniform float iTime;
uniform vec2  iResolution;

// --- distance and box helpers ---
float maxcomp(vec3 p) { return max(p.x, max(p.y, p.z)); }
float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return min(maxcomp(d), length(max(d, 0.0)));
}
vec2 iBox(vec3 ro, vec3 rd, vec3 rad) {
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    return vec2(max(max(t1.x, t1.y), t1.z),
                min(min(t2.x, t2.y), t2.z));
}

// --- rotation matrix used by Quilez ---
const mat3 ma = mat3(
     0.60, 0.00,  0.80,
     0.00, 1.00,  0.00,
    -0.80, 0.00,  0.60 );

// map() returns (distance, occlusion, material ID, unused)
vec4 map(vec3 p) {
    float d = sdBox(p, vec3(1.0));
    vec4 res = vec4(d, 1.0, 0.0, 0.0);

    float ani = smoothstep(-0.2, 0.2, -cos(0.5*iTime));
    float off = 1.5*sin(0.01*iTime);

    float s = 1.0;
    for (int m=0; m<4; m++) {
        p = mix(p, ma*(p + off), ani);
        vec3 a = mod(p*s, 2.0) - 1.0;
        s *= 3.0;
        vec3 r = abs(1.0 - 3.0*abs(a));
        float da = max(r.x, r.y);
        float db = max(r.y, r.z);
        float dc = max(r.z, r.x);
        float c  = (min(min(da, db), dc) - 1.0)/s;
        if (c > d) {
            d = c;
            res = vec4(d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0);
        }
    }
    return res;
}

// ray-marching intersection
vec4 intersect(vec3 ro, vec3 rd) {
    vec2 bb = iBox(ro, rd, vec3(1.05));
    if (bb.y < bb.x) return vec4(-1.0);
    float t = bb.x, tmax = bb.y;
    vec4 res = vec4(-1.0);
    for (int i=0; i<64; i++) {
        vec4 h = map(ro + rd*t);
        if (h.x < 0.002 || t > tmax) break;
        res = vec4(t, h.yzw);
        t += h.x;
    }
    return (t>tmax) ? vec4(-1.0) : res;
}

// soft shadow
float softshadow(vec3 ro, vec3 rd) {
    vec2 bb = iBox(ro, rd, vec3(1.05));
    float tmax = bb.y;
    float res = 1.0, t = bb.x;
    for (int i=0; i<64; i++) {
        float h = map(ro + rd*t).x;
        res = min(res, 64.0*h/t);
        if (res < 0.001) break;
        t += clamp(h, 0.005, 0.1);
        if (t > tmax) break;
    }
    return clamp(res, 0.0, 1.0);
}

// normal estimator
vec3 calcNormal(vec3 pos) {
    vec3 eps = vec3(.001, 0.0, 0.0);
    return normalize(vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x ));
}

// shading
vec3 render(vec3 ro, vec3 rd) {
    vec3 col = mix(vec3(0.3,0.2,0.1)*0.5, vec3(0.7,0.9,1.0), 0.5 + 0.5*rd.y);
    vec4 tmat = intersect(ro, rd);
    if (tmat.x > 0.0) {
        vec3 pos = ro + tmat.x*rd;
        vec3 nor = calcNormal(pos);
        vec3 matcol = 0.5 + 0.5*cos(vec3(0,1,2) + 2.0*tmat.z);
        float occ = tmat.y;
        vec3 light = normalize(vec3(1.0,0.9,0.3));
        float dif = max(dot(nor, light), 0.0);
        float sha = (dif>0.0) ? softshadow(pos+nor*0.01, light) : 1.0;
        vec3 hal = normalize(light - rd);
        float spe = dif*sha*pow(clamp(dot(hal,nor),0.0,1.0),16.0)
                    * (0.04 + 0.96*pow(clamp(1.0-dot(hal,light),0.0,1.0),5.0));
        float sky = 0.5 + 0.5*nor.y;
        float bac = max(0.4 + 0.6*dot(nor, vec3(-light.x,light.y,-light.z)),0.0);
        vec3 lin = vec3(0.0);
        lin += 1.0*dif*vec3(1.1,0.85,0.6)*sha;
        lin += 0.5*sky*vec3(0.1,0.2,0.4)*occ;
        lin += 0.1*bac*vec3(1.0,1.0,1.0)*(0.5+0.5*occ);
        lin += 0.25*occ*vec3(0.15,0.17,0.20);
        col = matcol*lin + spe*128.0;
    }
    col = 1.5*col/(1.0+col);
    return sqrt(col);
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x>=int(iResolution.x) || pix.y>=int(iResolution.y)) return;
    vec2 uv = (vec2(pix) + 0.5) / iResolution;

    // camera setup matching Shadertoy:
    vec3 ro = 1.1 * vec3(
        2.5*sin(0.25*iTime),
        1.0 + 1.0*cos(0.13*iTime),
        2.5*cos(0.25*iTime)
    );
    // build ray directions
    vec2 p = (uv*2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);
    vec3 ww = normalize(-ro);
    vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));
    vec3 vv = normalize(cross(ww, uu));
    vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);

    vec3 col = render(ro, rd);
    imageStore(imgOutput, pix, vec4(col,1.0));
}
